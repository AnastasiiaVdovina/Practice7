# Практичне заняття №7
## Завдання 1
### Умова
Використайте popen(), щоб передати вивід команди rwho (команда UNIX) до more (команда UNIX) у програмі на C.

### Рішення
Для початку розберемо команду rwho. Це UNIX-команда, яка виводить список користувачів, що наразі увійшли в систему на локальній мережі.
more - це команда для посторінкового перегляду тексту в терміналі. Коли вхідний потік великий і не поміщається на один екран, more зупиняє прокрутку і чекає на натискання клавіші, щоб показати наступну сторінку.
Тобто команда загалом у терміналі мала б вигляд:
```
rwho | more
```
| - це символ пайпа, що означає, що вивід першої команди (rwho) буде передано на вхід другої команди (more).
Команда popen(), використання якої вимагається в цьому завданні, це команда з бібліотеки stdio, яка має наступний синтаксис:
```
FILE *popen(const char *command, const char *mode);
```
Як бачимо, як аргументи на вхід вона приймає команду і режим, а повертає вказівник на потік, який можна використовувати для читання або запису в канал.
Для виконання цього завдання, було реалізовано програму, яка має простий алгоритм:
1) Використовується функція popen():
- popen("rwho", "r") — відкриття процесу rwho для читання (отримали його вивід).
- popen("more", "w") — відкриття процесу more для запису (передаємо йому текст на вхід).
2) Створення буферу char buffer[1024] — для тимчасового збереження рядків виводу rwho.
3) Цикл while (fgets(...) != NULL):
4) Зчитуємо кожен рядок виводу команди rwho.
5) Передаємо цей рядок у процес more за допомогою fputs().
6) Завершиуємо обидва процеси за допомогою pclose().

Отримали такий результат:

![image](https://github.com/user-attachments/assets/29026aae-e0bd-455d-a432-bdb64ff833ef)

Який означає, що rwhod не запущений на інших машинах, тому вивід порожній. 

## Завдання 2
### Умова
Напишіть програму мовою C, яка імітує команду ls -l в UNIX — виводить список усіх файлів у поточному каталозі та перелічує права доступу тощо.
(Варіант вирішення, що просто виконує ls -l із вашої програми, — не підходить.)

### Рішення
Моя рограма не використовує зовнішні команди, а натомість отримує всю інформацію через системні виклики.
Для цього довелося підключити декілька біліотек, наприклад <dirent.h> для роботи з каталогами та <sys/stat.h> для отримання інформації про файл.
Програма складається з двох функцій : print_permissions та main.
Перша приймає параметр mode( значення типу mode_t,яке містить інформацію про тип файлу і його права доступу).
Далі:
- S_ISDIR(mode) — перевіряє, чи це директорія (d) або звичайний файл (-).
- S_IRUSR, S_IWUSR, S_IXUSR — права читання/запису/виконання для власника.
- S_IRGRP, S_IWGRP, S_IXGRP — для групи.
- S_IROTH, S_IWOTH, S_IXOTH — для інших користувачів.

Результатом буде строка на зразок -rwxr-xr--, тобто аналогічно до результату команди ls -l.

Основий функціонал реалізовано у функції main. Спочатку ми відкриваємо поточний каталог, якщо не вдалося - виходимо з помилкою.
Далі цикл проходить по всіх файлах і підкаталогах у поточному каталозі. Кожна ітерація повертає структуру dirent, яка містить, зокрема, ім'я файлу (entry->d_name).
Також в цій програмі я вирішила пропускати приховані файли (ті, що починаються з крапки, тобто  .gitignore і тд).
Далі викликаємо функцію stat(), яка заповнює структуру file_stat інформацією про файл: права доступу, розмір, дату модифікації, виводимо права доступу за допомогою функції print_permissions, а потім — ім’я файлу.
В кінці закриваємо каталог. 

Отримаємо такий результат виконання:

![image](https://github.com/user-attachments/assets/bf5f1373-ece2-4a99-8703-28b94bf2f830)

А ось для порівняння результат виконання команди ls -l:

![image](https://github.com/user-attachments/assets/faeb98fa-9967-4935-92d2-09c7d007c944)

## Завдання 3
### Умова
Напишіть програму, яка друкує рядки з файлу, що містять слово, передане як аргумент програми (проста версія утиліти grep в UNIX).

### Рішення
Для вирішення цієї задачі протрібно знати, що таке argc та argv[], тому її вирішення для багатьох може бути недоступним.
Мій варіант рішення працює наступним чином: 
1) спочатку перевіряємо, чи отримала програма необхідну кількість аргументів на вхід, якщо ні, то повідомляємо про помилку.
2) слово, яке ми шукаємо - це argv[1], а ім'я файлу - це argv[2]. зберігаємо ці змінні
3) відкриваємо файл для читання
4) за допомогою циклу while та попередньо задекларованої змінної line(з обмеженим розміром до 1 мб) порядково зчитуємо файл через fgets
5) у циклі для кожного рядка викликається функція strstr(line, word), яка перевіряє, чи входить підрядок word у рядок line, якщо входить — програма друкує цей рядок.
6) закриваємо файл і завершуємо роботу програми.

Для коректного запуску програми пишемо команду в такому порядку:
```
./task3 word filename
```

Отримуємо такі результати:

![image](https://github.com/user-attachments/assets/adaed1fe-f871-41d6-87bd-a08e91d28a74)

при наступному змісті файлу:

![image](https://github.com/user-attachments/assets/f3e5548e-c15a-4dc4-af4f-1071f539df7d)


## Завдання 4
### Умова
 Напишіть програму, яка виводить список файлів, заданих у вигляді аргументів, з зупинкою кожні 20 рядків, доки не буде натиснута клавіша (спрощена версія утиліти more в UNIX).

### Рішення
Програма складається з двох функцій : show_file та main.
Перша з них відповідає за поетапне виведення одного файлу. Спочатку відкриваємо файл через fopen та оброблюємо потенційну помилку відкриття. Далі циклом за допомогою fgets зчитуємо рядки, і перевіряємо, чи не досягла кількість зчитаних рядків 20ти, якщо так, то очікуємо натиснення Enter для продовження зчитування.

Функція main в свою чергу перевіряє кількість аргументів на вхід, і якщо програму запущено правильно, то в циклі перебираємо передані файли, і для кожного виводимо заголовок з ім'ям файлу та викликаємо функцію show_file.

Як резльтат отримуємо:

![image](https://github.com/user-attachments/assets/f4b71d6d-2bf6-4b2e-9b36-1572e5020dc6)

Після натиснення Enter:

![image](https://github.com/user-attachments/assets/9dcb3f3a-fe6c-4f48-86aa-b4a90caf29b0)

Після натиснення Enter повторно:

![image](https://github.com/user-attachments/assets/c1bfd3fa-f2a1-4b1b-a494-ab44129d22af)

## Завдання 5
### Умова
Напишіть програму, яка перелічує всі файли в поточному каталозі та всі файли в підкаталогах.

### Рішення
Написана програма складається з двох функцій: list_files та main.
Перша реалізовує рекурсивний обхід каталогів. Спочатку ми відкриваємо каталог, далі у циклі читаємо елементи у каталозі, пропускаючи посилання на поточний і батьківський каталоги ( . і ..) , щоб уникнути нескінченної рекурсії.
Далі об’єднуємо шлях до поточного каталогу (path, який передається в цю функцію як аргумент) з назвою файлу/каталогу (entry->d_name) через /, викоистовуючи для цього snprintf.
Потім використовуємо stat(), який заповнює структуру statbuf інформацією про файл.
Перевіряємо тип елемента:
- S_ISDIR(statbuf.st_mode) — макрос, який перевіряє, чи є об'єкт каталогом. Якщо так — рекурсивно викликаємо list_files(fullpath) для підкаталогу.
- S_ISREG(statbuf.st_mode) — перевірка на звичайний файл. Якщо так — виводимо повний шлях до файлу на екран.
В кінці роботи закриваємо каталог.

У функції main викликаємо функцію list_files, в яку передаємо "." , що означає поточний каталог.

Маємо такий результат:

![image](https://github.com/user-attachments/assets/0ded0dee-4bd4-4112-b8a5-d9211d6c9912)


## Завдання 6
### Умова
 Напишіть програму, яка перелічує лише підкаталоги у алфавітному порядку.



### Рішення
Програма складається з структури для збереження списку імен підкаталогів, функції add_to_list для додавання імені до списку, функції compare_names для порівняння рядків для сортування, функції list_sublirs_sorted яка збирає та сортує підкаталоги та головної фукнції main.
1) Структура включає в себе масив рядків з іменами підкаталогів, кількість записаних імен та поточну місткість масиву.
2) Функція list_subdirs_sorted() виконує всю основну логіку.
На початку функція відкриває каталог за допомогою opendir(path).
Далі створюється структура типу DirList, яка містить список імен каталогів.
За допомогою readdir() послідовно зчитуються всі записи з каталогу.
Потім за допомогою snprintf() формується повний шлях до елемента як у попередній програмі.
Функція stat() використовується для отримання інформації про об’єкт. Якщо це об'єкт типу "каталог" (перевіряється через макрос S_ISDIR()), його ім’я додається в список через функцію add_to_list(). Після завершення читання всіх об’єктів каталог закривається функцією closedir().
Потім список імен каталогів сортується за алфавітом за допомогою qsort() із функцією порівняння compare_names().
В результаті всі імена виводяться через printf(), і виділена під них пам’ять звільняється через free().

3) Функція add_to_list() відповідає за динамічне зберігання імен підкаталогів.
Вона приймає вказівник на структуру DirList, яка містить масив рядків, кількість елементів у списку (count) та поточну місткість (capacity). Якщо кількість елементів досягла місткості, функція автоматично збільшує її (подвоює, або встановлює в 10, якщо ще не ініціалізовано) за допомогою realloc(). Потім ім’я підкаталогу копіюється функцією strdup() (щоб зберігати окрему копію, не прив’язану до змінного буфера) і додається до масиву. Лічильник count збільшується на 1.

4) Функція compare_names() є допоміжною, і передається як параметр у функцію qsort().
Функція приймає два вказівники на елементи масиву (в нашому випадку — це вказівники на рядки, тобто char **). Вона виконує перетворення вказівників до типу char * і порівнює значення рядків за допомогою стандартної функції strcmp().

5) Головна функція main визначає шлях до каталогу й викликає функцію list_subdirs_sorted(path) для його обробки.
Якщо користувач запустив програму з аргументом (шляхом до каталогу), то програма використовує цей шлях. Якщо аргумент не передано, програма працює з поточним каталогом ".". 

Багато ключових функцій та принципів, які були використані у початковій програмі (перелік файлів у каталозі та його підкаталогах), успішно адаптовані в цій програмі.

Маємо такий результат:

![image](https://github.com/user-attachments/assets/5fbb6ceb-19bf-4111-b298-58e2f4da3ca5)

## Завдання 7
### Умова
Напишіть програму, яка показує користувачу всі його/її вихідні програми на C, а потім в інтерактивному режимі запитує, чи потрібно надати іншим дозвіл на читання (read permission); у разі ствердної відповіді — такий дозвіл повинен бути наданий.

### Рішення

## Завдання 8
### Умова
Напишіть програму, яка надає користувачу можливість видалити будь-який або всі файли у поточному робочому каталозі. Має з’являтися ім’я файлу з запитом, чи слід його видалити.

### Рішення
Прогрма працює наступним чином:
Спершу програма відкриває поточний каталог за допомогою функції opendir("."), яка повертає покажчик на структуру DIR, що описує відкритий каталог.
Далі оголошуються три змінні: покажчик entry на структуру dirent для зчитування імен файлів, змінна st типу struct stat для збереження інформації про кожен файл, і масив answer[10] для збереження відповіді користувача.
Усередині циклу while ((entry = readdir(dir)) != NULL) програма по черзі обробляє всі записи каталогу.
Для кожного файлу, який не пропущено, викликається функція stat(), яка заповнює структуру st інформацією про файл. 
Далі, якщо файл є звичайним файлом (перевірка S_ISREG(st.st_mode)), програма виводить на екран повідомлення з іменем файлу та запитом до користувача. Відповідь користувача зчитується за допомогою fgets(answer, sizeof(answer), stdin).
Видаляємо символ нового рядка у відповіді.
Після цього відповідь користувача порівнюється з можливими варіантами ствердної відповіді, тобто "yes" або "y". Якщо відповідь збігається з одним із них, викликається функція remove(entry->d_name), яка видаляє файл. Якщо файл успішно видалено, виводиться відповідне повідомлення.
Якщо відповідь користувача не ствердна, файл не видаляється, а програма виводить повідомлення про те, що даний файл було пропущено.
Після завершення обробки всіх файлів каталог закривається.

Результат:

![image](https://github.com/user-attachments/assets/614e1c66-9164-47b5-813c-8d133e5e2e2b)

## Завдання 9
### Умова
 Напишіть програму на C, яка вимірює час виконання фрагмента коду в мілісекундах.
 
### Рішення

В якості рішення для цього завдання я написала простий код, який використовує функцію clock() з бібліотеки time.h.
Ми вже практикували такі задачі в курсі Основ програмування. Спочатку ми використовуємо фукнцію clock() і зберігаємо результат у змінну start, потім виконуємо фрагмент демонстраційного коду, і далі знову clock(). Для отримання результату рахуємо різницю end - start та ділимо її на константу CLOCKS_PER_SEC, щоб перевести в секунди.
В якості демонстарційного фрагменту коду я використала циклічну суму, щоб побачити хоч якусь різницю у часі.
Спочатку як результат я вирішила отримувати час в секундах, і ось що з цього вийшло:

![image](https://github.com/user-attachments/assets/85edf375-fc2e-48a4-8d7a-a4154242a75b)

Потім я згадала, що в умові просили час в мілісекундах, тож помноживши на 1000 я отримала такий результат в мілісекундах:

![image](https://github.com/user-attachments/assets/64ba9ce6-6e8a-4934-b7fc-463cd308e3a7)


## Завдання 10
### Умова
Напишіть програму мовою C для створення послідовності випадкових чисел з плаваючою комою у діапазонах:
 (a) від 0.0 до 1.0
 (b) від 0.0 до n, де n — будь-яке дійсне число з плаваючою точкою.
 Початкове значення генератора випадкових чисел має бути встановлене так, щоб гарантувати унікальну послідовність.

### Рішення

Для реалізації цього завдання я використала свої навички знову з курсу Основ програмування.
Я використала srand(time(NULL)) з бібліотеки time.h.
Програма складається з декількох функцій:
1) Функція для генерації числа від 0 до 1. Вона повертає ```(double)rand() / (double)RAND_MAX;```.
2) Функція для генерації числа від 0 до n, яка використовує попередню функцію як базову, і повертає ```rand_0_1() * n```.
3) Функція для друку рандомних чисел. Я дійшла до неї не одразу, але вирішила виділити цей код в окрему функцію, бо за її відсутності в мене повторювався фрагмент коду у функції main, і я подумала що це не дуже добре. Ця функція циклічно друкує рандомні числа, викликаючи попередню для їх генерації.
4) Головна функція. В ній ми ініціалізуємо генератор випадкових чисел за допомогою srand(time(NULL)) та виводимо результати, викликаючи функцію для друку рандомних чисел.
Як результат отримуємо:

![image](https://github.com/user-attachments/assets/63ba0136-6a16-4946-a19c-930f4c1b2ed3)

## Індивідувальне завдання
### Умова
Напишіть програму, яка визначає структуру ієрархії директорій для поточного користувача, починаючи з кореня, виключаючи циклічні посилання, але зберігаючи символьні.

### Рішення
